# Trees Data Structure: From Beginner to Advanced

## Definition of Trees

A **tree** is a nonlinear hierarchical data structure comprising nodes connected by edges. Each node contains a value or data and may have child nodes. The topmost node is called the **root**, and nodes without children are termed **leaves**. Trees are widely used to represent hierarchical relationships and facilitate efficient data storage and retrieval.

## Tree Terminology

- **Root**: The top node in a tree.
- **Parent**: A node that has child nodes.
- **Child**: A node that descends from another node.
- **Siblings**: Nodes that share the same parent.
- **Leaf**: A node with no children.
- **Internal Node**: A node with at least one child.
- **Degree**: The number of children a node has.
- **Level**: The depth or distance from the root node.
- **Height**: The length of the longest path from a node to a leaf.
- **Depth**: The length of the path from the root to a node.
- **Subtree**: A tree consisting of a node and its descendants.
- **Path**: A sequence of nodes and edges connecting a node with a descendant.

## The Tree Abstract Data Type (ADT)

A **Tree ADT** defines the hierarchical structure where each node has a parent and possibly many children. The primary operations supported by a Tree ADT include:

- `root()`: Returns the position of the tree's root.
- `parent(p)`: Returns the position of node `p`'s parent.
- `num_children(p)`: Returns the number of children of node `p`.
- `children(p)`: Generates an iteration of node `p`'s children.
- `is_root(p)`: Checks if node `p` is the root.
- `is_leaf(p)`: Checks if node `p` is a leaf.
- `is_empty()`: Checks if the tree is empty.
- `positions()`: Generates an iteration of all positions (nodes) in the tree.
- `__len__()`: Returns the total number of nodes in the tree.

## Implementing a Tree in Python

Below is an abstract base class representing a tree structure:

```python
class Tree:
    """Abstract base class representing a tree structure."""

    class Position:
        """An abstraction representing the location of a single element."""

        def element(self):
            """Return the element stored at this Position."""
            raise NotImplementedError('must be implemented by subclass')

        def __eq__(self, other):
            """Return True if other Position represents the same location."""
            raise NotImplementedError('must be implemented by subclass')

    def root(self):
        """Return Position representing the tree's root (or None if empty)."""
        raise NotImplementedError('must be implemented by subclass')

    def parent(self, p):
        """Return Position representing p's parent (or None if p is root)."""
        raise NotImplementedError('must be implemented by subclass')

    def num_children(self, p):
        """Return the number of children that Position p has."""
        raise NotImplementedError('must be implemented by subclass')

    def children(self, p):
        """Generate an iteration of Positions representing p's children."""
        raise NotImplementedError('must be implemented by subclass')

    def __len__(self):
        """Return the total number of elements in the tree."""
        raise NotImplementedError('must be implemented by subclass')

    def is_root(self, p):
        """Return True if Position p represents the root of the tree."""
        return self.root() == p

    def is_leaf(self, p):
        """Return True if Position p does not have any children."""
        return self.num_children(p) == 0

    def is_empty(self):
        """Return True if the tree is empty."""
        return len(self) == 0
```

## Binary Tree

A **binary tree** is a tree data structure where each node has at most two children, referred to as the left child and the right child. This structure is foundational for more complex tree types like binary search trees and AVL trees.

### Properties of Binary Trees

- Each node has at most two children.
- The left child precedes the right child in order.
- Common types include full binary trees, complete binary trees, and perfect binary trees.

## The Binary Tree Abstract Data Type

The **Binary Tree ADT** extends the Tree ADT with additional methods specific to binary trees:

- `left(p)`: Returns the position of node `p`'s left child.
- `right(p)`: Returns the position of node `p`'s right child.
- `sibling(p)`: Returns the position of node `p`'s sibling.

## Linked Structure for Binary Trees in Python

Below is a Python implementation of a linked structure for a binary tree:

```python
class LinkedBinaryTree:
    """Linked representation of a binary tree structure."""

    class _Node:
        """Lightweight, nonpublic class for storing a node."""
        __slots__ = '_element', '_parent', '_left', '_right'

        def __init__(self, element, parent=None, left=None, right=None):
            self._element = element
            self._parent = parent
            self._left = left
            self._right = right

    class Position:
        """An abstraction representing the location of a single element."""

        def __init__(self, container, node):
            """Constructor should not be invoked by user."""
            self._container = container
            self._node = node

        def element(self):
            """Return the element stored at this Position."""
            return self._node._element

        def __eq__(self, other):
            """Return True if other is a Position representing the same location."""
            return type(other) is type(self) and other._node is self._node

    def __init__(self):
        """Create an initially empty binary tree."""
        self._root = None
        self._size = 0

    def __len__(self):
        """Return the total number of elements in the tree."""
        return self._size

    def root(self):
        """Return the root Position of the tree (or None if tree is empty)."""
        return self._make_position(self._root)

    def parent(self, p):
        """Return the Position of p's parent (or None if p is root)."""
        node = self._validate(p)
        return self._make_position(node._parent)

    def left(self, p):
        """Return the Position of p's left child (or None if no left child)."""
        node = self._validate(p)
        return self._make_position(node._left)

    def right(self, p):
        """Return the Position of p's right child (or None if no right child)."""
        node = self._validate(p)
        return self._make_position(node._right)

    def num_children(self, p):
        """Return the number of children of Position p."""
        node = self._validate(p)
        count = 0
        if node._left is not None:
            count += 1
        if node._right is not None:
            count += 1
        return count

    def _validate(self, p):
        """Return associated node, if position is valid
        ...
```

## Tree Traversal Algorithms

Tree traversal is the process of visiting each node in the tree in a specific order. There are two primary types:

### Depth-First Search (DFS)

#### Types of DFS:
- **Inorder Traversal (Left, Root, Right)**
- **Preorder Traversal (Root, Left, Right)**
- **Postorder Traversal (Left, Right, Root)**

### Breadth-First Search (BFS)

BFS, also known as **Level Order Traversal**, visits all nodes at the present depth level before moving on to the nodes at the next depth level.

## Implementing Tree Traversals in Python

### Inorder Traversal:
```python
def inorder(node):
    if node is not None:
        inorder(node.left)
        print(node.element)
        inorder(node.right)
```

### Preorder Traversal:
```python
def preorder(node):
    if node is not None:
        print(node.element)
        preorder(node.left)
        preorder(node.right)
```

### Postorder Traversal:
```python
def postorder(node):
    if node is not None:
        postorder(node.left)
        postorder(node.right)
        print(node.element)
```

### Breadth-First Traversal:
```python
from collections import deque

def level_order(root):
    if root is None:
        return
    queue = deque([root])
    while queue:
        current = queue.popleft()
        print(current.element)
        if current.left:
            queue.append(current.left)
        if current.right:
            queue.append(current.right)
```

