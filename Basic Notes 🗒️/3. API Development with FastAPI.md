# üìö API Development Guide

## üèóÔ∏è Project Structure

A well-organized API project structure makes development easier:

```
src/
  ‚îú‚îÄ‚îÄ api/                 # API routes
  ‚îú‚îÄ‚îÄ middleware/          # Custom middleware
  ‚îú‚îÄ‚îÄ controllers/         # Business logic
  ‚îú‚îÄ‚îÄ services/            # External services integration
  ‚îú‚îÄ‚îÄ models/              # Data models
  ‚îú‚îÄ‚îÄ utils/               # Helper functions
  ‚îú‚îÄ‚îÄ config/              # Configuration files
  ‚îî‚îÄ‚îÄ tests/               # Test files
```

Keep routes separate from business logic for cleaner code.

## üõ£Ô∏è API Routes Design

Follow RESTful principles for clear, predictable APIs:

| Method | Purpose |
|--------|---------|
| GET    | Fetch data |
| POST   | Create new resource |
| PUT    | Update entire resource |
| PATCH  | Partial update |
| DELETE | Remove resource |

Example route naming:
- `/users` - List all users
- `/users/:id` - Single user operations
- `/users/:id/posts` - Get posts of a specific user

## üìù Parameters & Request Handling

### Path Parameters

Used in URL path for identifying resources:

```javascript
// Express example
app.get('/users/:id', (req, res) => {
  const userId = req.params.id;
  // Get user with userId
});
```

### Query Parameters

For filtering, sorting, and pagination:

```
/products?category=electronics&sort=price&order=desc
```

Access with:
```javascript
const category = req.query.category;
```

### Request Body

For sending complex data (POST/PUT/PATCH):

```javascript
app.post('/users', (req, res) => {
  const userData = req.body;
  // Create user with userData
});
```

### Form Data & File Uploads

Use middleware like multer for file uploads:

```javascript
// Simplified example
const upload = multer({ dest: 'uploads/' });
app.post('/profile', upload.single('avatar'), (req, res) => {
  // req.file contains upload info
});
```

### Header & Cookie Parameters

For auth tokens and session data:

```javascript
const token = req.headers.authorization;
const sessionData = req.cookies.session;
```

## üìÑ Pagination Techniques

Implement pagination to handle large data sets:

```
/articles?page=2&limit=10
```

Response should include:
- Current page
- Total pages
- Total items
- Next/previous page links

## üîê Authentication & Authorization

### Common Auth Methods:

1. **JWT (JSON Web Tokens)**
   ```javascript
   // Verify token
   const token = req.headers.authorization.split(' ')[1];
   const decoded = jwt.verify(token, process.env.JWT_SECRET);
   ```

2. **OAuth 2.0**
   - For third-party authentication (Google, GitHub, etc.)

3. **API Keys**
   ```javascript
   // Check API key
   const apiKey = req.headers['x-api-key'];
   if (!validApiKey(apiKey)) return res.status(401).send('Unauthorized');
   ```

## üîÑ Middleware Implementation

Middleware runs between request and response:

```javascript
// Authentication middleware
function authenticate(req, res, next) {
  const token = req.headers.authorization;
  if (!token) return res.status(401).send('No token provided');
  
  try {
    req.user = verifyToken(token);
    next();
  } catch (error) {
    res.status(401).send('Invalid token');
  }
}

// Use middleware
app.get('/protected-route', authenticate, (req, res) => {
  // Access req.user here
});
```

## üåê CORS Handling

Enable Cross-Origin Resource Sharing for frontend access:

```javascript
// Simple CORS setup
app.use(cors({
  origin: 'https://yourdomain.com',
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));
```

## üì§ Response Handling

Consistent response format improves API usability:

```javascript
// Success response
res.status(200).json({
  success: true,
  data: result,
  message: 'Operation successful'
});

// Error response
res.status(400).json({
  success: false,
  error: 'Invalid input',
  details: errorDetails
});
```

## üç™ Cookie Management

For session management and auth:

```javascript
// Set cookie
res.cookie('sessionId', sessionId, {
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
});

// Clear cookie
res.clearCookie('sessionId');
```

## üìã Headers Management

Set headers for security and caching:

```javascript
res.setHeader('Cache-Control', 'no-store');
res.setHeader('Content-Type', 'application/json');
```

## üóÉÔ∏è Database Integration

Example database connection with Mongoose (MongoDB):

```javascript
// Connection setup
mongoose.connect(process.env.DATABASE_URL, {
  useNewUrlParser: true,
  useUnifiedTopology: true
})
.then(() => console.log('Database connected'))
.catch(err => console.error('Database connection error:', err));
```

Common ORM/ODMs:
- Mongoose (MongoDB)
- Sequelize (SQL databases)
- Prisma (SQL/NoSQL databases)

## üì¶ Caching with Redis

Improve performance with caching:

```javascript
// Basic Redis caching example
app.get('/products', async (req, res) => {
  // Check cache first
  const cachedData = await redisClient.get('products');
  if (cachedData) return res.json(JSON.parse(cachedData));
  
  // If not in cache, get from database
  const products = await Product.find();
  
  // Store in cache (expire after 1 hour)
  await redisClient.set('products', JSON.stringify(products), 'EX', 3600);
  
  res.json(products);
});
```

## ‚è±Ô∏è Background Tasks

For time-consuming operations:

```javascript
// Using a job queue like Bull
const queue = new Bull('email-queue');

// Add job to queue
queue.add({
  to: user.email,
  subject: 'Welcome!',
  body: 'Welcome to our platform'
});

// Process jobs
queue.process(async (job) => {
  await sendEmail(job.data);
});
```

## üîí API Security Best Practices

1. **Input Validation**: Validate all user input
   ```javascript
   const { error, value } = userSchema.validate(req.body);
   if (error) return res.status(400).json({ error: error.details });
   ```

2. **Rate Limiting**: Prevent abuse
   ```javascript
   const limiter = rateLimit({
     windowMs: 15 * 60 * 1000, // 15 minutes
     max: 100 // 100 requests per windowMs
   });
   app.use('/api/', limiter);
   ```

3. **Security Headers**: Use Helmet middleware
   ```javascript
   app.use(helmet());
   ```

## ‚ùå Error Handling

Centralized error handling improves code quality:

```javascript
// Global error handler
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(err.statusCode || 500).json({
    success: false,
    message: err.message || 'Server error',
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
  });
});

// Custom error class
class AppError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
  }
}
```

## üîÑ API Versioning

Future-proof your API with versioning:

1. **URL Path Versioning**
   ```
   /api/v1/users
   /api/v2/users
   ```

2. **Header Versioning**
   ```
   Accept: application/vnd.company.v1+json
   ```

## ‚ö° Performance Optimization

1. **Compression**: Reduce response size
   ```javascript
   app.use(compression());
   ```

2. **Pagination**: Limit data volume

3. **Caching**: Reduce database load

4. **Indexing**: Speed up database queries

## üö´ Request Limiting

Protect your API from abuse:

```javascript
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests, please try again later'
});

// Apply to all requests
app.use(limiter);

// Or specific routes
app.use('/api/auth/', authLimiter);
```

## üîå WebSockets

For real-time features:

```javascript
// Basic Socket.io setup
const io = require('socket.io')(server);

io.on('connection', (socket) => {
  console.log('New client connected');
  
  socket.on('message', (data) => {
    io.emit('message', data); // Broadcast to all clients
  });
  
  socket.on('disconnect', () => {
    console.log('Client disconnected');
  });
});
```

## üìä GraphQL Integration

Alternative to REST for flexible queries:

```javascript
// Basic GraphQL schema
const typeDefs = gql`
  type User {
    id: ID!
    name: String!
    email: String!
  }
  
  type Query {
    users: [User]
    user(id: ID!): User
  }
`;

// Resolvers
const resolvers = {
  Query: {
    users: () => users,
    user: (_, { id }) => users.find(user => user.id === id)
  }
};
```

## üß™ Testing Strategies

1. **Unit Testing**: Test individual functions
   ```javascript
   test('should calculate total correctly', () => {
     expect(calculateTotal([10, 20, 30])).toBe(60);
   });
   ```

2. **Integration Testing**: Test APIs end-to-end
   ```javascript
   test('GET /users should return users', async () => {
     const res = await request(app).get('/users');
     expect(res.status).toBe(200);
     expect(res.body).toHaveProperty('data');
   });
   ```

3. **Load Testing**: Test performance under load

## üöÄ Deployment Best Practices

1. **Environment Variables**: Use `.env` files
   ```
   # .env.development
   PORT=3000
   DATABASE_URL=mongodb://localhost:27017/dev
   
   # .env.production
   PORT=8080
   DATABASE_URL=mongodb+srv://...
   ```

   Load with:
   ```javascript
   require('dotenv').config({
     path: `.env.${process.env.NODE_ENV}`
   });
   ```

2. **CI/CD Pipeline**: Automate testing and deployment

3. **Containerization**: Use Docker for consistent environments
   ```
   # Dockerfile example
   FROM node:16
   WORKDIR /app
   COPY package*.json ./
   RUN npm install
   COPY . .
   CMD ["npm", "start"]
   ```

## üìù Documentation

Document your API for better usability:

1. **Swagger/OpenAPI**: Interactive documentation
   ```javascript
   const swaggerOptions = {
     definition: {
       openapi: '3.0.0',
       info: {
         title: 'My API',
         version: '1.0.0',
         description: 'API documentation'
       }
     },
     apis: ['./routes/*.js']
   };
   
   const swaggerDocs = swaggerJsdoc(swaggerOptions);
   app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerDocs));
   ```

2. **README**: Basic setup instructions

3. **API Reference**: Endpoint details with examples

## üîë Environment Variables

Environment variables manage configuration across environments:

```
# .env.local (development)
PORT=3000
NODE_ENV=development
DATABASE_URL=mongodb://localhost:27017/myapp
JWT_SECRET=dev_secret_key
API_URL=http://localhost:3000/api

# .env.production
PORT=8080
NODE_ENV=production
DATABASE_URL=mongodb+srv://user:pass@cluster.mongodb.net/myapp
JWT_SECRET=long_secure_random_string
API_URL=https://api.myapp.com
```

Access in code:
```javascript
const port = process.env.PORT || 3000;
const isProduction = process.env.NODE_ENV === 'production';
```

**NEVER commit .env files with secrets to version control!**

## üìå Important Notes & Summary

1. **Security First**: Always validate input, use HTTPS, implement proper authentication
2. **Consistent Responses**: Standardize response format
3. **Documentation**: Keep API docs updated
4. **Testing**: Implement automated testing
5. **Performance**: Monitor and optimize as needed
6. **Versioning**: Plan for API evolution
